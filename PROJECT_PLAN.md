# Подробный план реализации проекта Titanic

## Обзор проекта
**Цель:** Предсказать выживаемость пассажиров Титаника на основе их характеристик  
**Метрика:** Accuracy (процент правильных предсказаний)  
**Тип задачи:** Бинарная классификация (Survived: 0 или 1)

---

## Этап 1: Исследовательский анализ данных (EDA)

### 1.1 Базовый обзор данных
- [x] Загрузка данных (train.csv, test.csv)
- [x] Проверка размеров датасетов
- [x] Просмотр структуры данных (info(), describe())
- [x] Проверка пропущенных значений

### 1.2 Анализ целевой переменной
- [x] Распределение целевой переменной Survived
- [x] Визуализация баланса классов
- [x] Базовая статистика выживаемости

### 1.3 Анализ числовых признаков
- [x] Age (возраст) - 177 пропусков в train
- [x] Fare (цена билета) - 1 пропуск в test
- [x] SibSp (количество братьев/сестер/супругов)
- [x] Parch (количество родителей/детей)
- [x] Корреляционный анализ всех числовых признаков
- [x] Распределения и выбросы для каждого признака
- [x] Взаимосвязь числовых признаков с выживаемостью
- [x] Статистика по группам выживаемости
- [x] Анализ выживаемости по возрастным группам
- [x] Анализ выживаемости по ценовым группам

### 1.4 Анализ категориальных признаков
- [x] Pclass (класс каюты: 1, 2, 3)
- [x] Sex (пол: male, female)
- [x] Embarked (порт посадки: C, Q, S) - 2 пропуска в train
- [x] Ticket (номер билета) - анализ уникальности и паттернов
- [x] Name (имя) - извлечение титулов
- [x] Cabin (каюта) - 687 пропусков в train, анализ структуры
- [x] Анализ выживаемости по категориальным признакам
- [x] Сводная таблица выживаемости

### 1.5 Визуализации
- [x] Корреляционная матрица
- [x] Гистограммы для числовых признаков
- [x] Графики выживаемости по категориальным признакам
- [x] Box plots для числовых признаков по выживаемости
- [x] Violin plots для Age и Fare
- [x] Многомерные визуализации (pair plots)
- [x] Комплексные визуализации по комбинациям признаков

---

## Этап 2: Обработка пропущенных значений

### 2.1 Age (возраст)
- [x] Анализ зависимости Age от других признаков (Pclass, Sex, Title)
- [x] Заполнение медианой/средним по группам
- [x] Применение к test.csv
- [x] Проверка распределения до и после заполнения

### 2.2 Embarked (порт посадки)
- [x] Анализ связи с другими признаками (Pclass, Fare)
- [x] Заполнение модой или наиболее вероятным значением
- [x] Проверка влияния на выживаемость

### 2.3 Fare (цена билета)
- [x] Анализ пропусков в test.csv
- [x] Заполнение медианой по Pclass + Embarked
- [x] Проверка заполнения

### 2.4 Cabin (каюта)
- [x] Создание признака is_Cabin (есть/нет каюта)
- [x] Создание признака Id_cabin (первая буква)
- [x] Создание признака Cabin_Count
- [x] Анализ влияния на выживаемость
- [x] Решение: использовать производные признаки (is_Cabin, Id_cabin, Cabin_Count)
- [x] Применение к test.csv

---

## Подробное описание этапа 2: Обработка пропущенных значений

### Общие принципы обработки пропусков

**Важно:** Все изменения должны применяться одинаково к train и test датасетам!

1. **Анализ пропусков:**
   - Определить количество и процент пропусков для каждого признака
   - Понять природу пропусков: случайные (MCAR), зависящие от других признаков (MAR), или систематические (MNAR)
   - Проанализировать связь пропусков с целевой переменной

2. **Стратегии заполнения:**
   - **Простое удаление** - только если пропусков очень мало (<5%) и они случайны
   - **Заполнение константой** - для категориальных признаков (мода)
   - **Заполнение статистикой** - среднее, медиана для числовых
   - **Заполнение по группам** - более точное, учитывает другие признаки
   - **Модельное предсказание** - использование ML моделей для предсказания пропусков

3. **Проверка качества:**
   - Сравнить распределения до и после заполнения
   - Проверить влияние на корреляции
   - Убедиться, что не созданы артефакты

---

### 2.1 Age (возраст) - 177 пропусков (19.87%)

#### Шаг 1: Анализ зависимости Age от других признаков

**Что делать:**
1. Проанализировать средний/медианный возраст по группам:
   - По Pclass (классу каюты)
   - По Sex (полу)
   - По Title (титулу) - очень важно!
   - По комбинациям (Pclass + Sex, Pclass + Title)

2. Визуализировать распределения:
   - Box plots Age по группам
   - Гистограммы Age для каждой группы
   - Проверить, есть ли значимые различия

**Код для анализа:**
```python
# Анализ среднего возраста по группам
print("Средний возраст по Pclass:")
print(df_train.groupby('Pclass')['Age'].mean())

print("\nСредний возраст по Sex:")
print(df_train.groupby('Sex')['Age'].mean())

print("\nСредний возраст по Title:")
print(df_train.groupby('Title')['Age'].mean())

# Комбинации
print("\nСредний возраст по Pclass и Sex:")
print(df_train.groupby(['Pclass', 'Sex'])['Age'].mean())
```

#### Шаг 2: Заполнение Age

**Вариант A: Заполнение медианой по группам (рекомендуется)**

**Алгоритм:**
1. Для каждого пассажира с пропущенным Age:
   - Определить его группу (например, по Pclass + Sex + Title)
   - Найти медиану Age для этой группы
   - Заполнить пропуск этой медианой

2. Если для группы нет данных, использовать более общую группу (например, только Pclass + Sex)

**Код:**
```python
# Создать функцию для заполнения Age
def fill_age(row):
    if pd.notna(row['Age']):
        return row['Age']
    
    # Пробуем найти медиану по группе Pclass + Sex + Title
    group = df_train[(df_train['Pclass'] == row['Pclass']) & 
                     (df_train['Sex'] == row['Sex']) & 
                     (df_train['Title'] == row['Title'])]
    
    if len(group) > 0 and group['Age'].notna().sum() > 0:
        return group['Age'].median()
    
    # Если не нашли, пробуем Pclass + Sex
    group = df_train[(df_train['Pclass'] == row['Pclass']) & 
                     (df_train['Sex'] == row['Sex'])]
    
    if len(group) > 0 and group['Age'].notna().sum() > 0:
        return group['Age'].median()
    
    # В крайнем случае - общая медиана
    return df_train['Age'].median()

# Применить к train и test
df_train['Age'] = df_train.apply(fill_age, axis=1)
df_test['Age'] = df_test.apply(fill_age, axis=1)
```

**Вариант B: Использование модели для предсказания Age**

**Алгоритм:**
1. Обучить модель (Random Forest, KNN) на пассажирах с известным Age
2. Использовать признаки: Pclass, Sex, Title, SibSp, Parch, Fare, Embarked
3. Предсказать Age для пассажиров с пропусками

**Код:**
```python
from sklearn.ensemble import RandomForestRegressor

# Подготовка данных для модели
age_features = ['Pclass', 'Sex', 'Title', 'SibSp', 'Parch', 'Fare', 'Embarked']
# Нужно закодировать категориальные признаки

# Разделить на данные с Age и без Age
train_age = df_train[df_train['Age'].notna()]
test_age = df_train[df_train['Age'].isna()]

# Обучить модель
# ... (код обучения)

# Предсказать
# ... (код предсказания)
```

#### Шаг 3: Проверка качества заполнения

**Что проверить:**
1. Распределение Age до и после заполнения (гистограммы, box plots)
2. Статистики (среднее, медиана, стандартное отклонение)
3. Корреляции Age с другими признаками
4. Влияние на выживаемость

**Код:**
```python
# Сравнение распределений
fig, axes = plt.subplots(1, 2, figsize=(14, 5))
axes[0].hist(df_train_original['Age'].dropna(), bins=30, alpha=0.7, label='До заполнения')
axes[1].hist(df_train['Age'], bins=30, alpha=0.7, label='После заполнения', color='green')
# ... визуализация

# Статистики
print("Статистики Age до заполнения:")
print(df_train_original['Age'].describe())
print("\nСтатистики Age после заполнения:")
print(df_train['Age'].describe())
```

---

### 2.2 Embarked (порт посадки) - 2 пропуска в train

#### Шаг 1: Анализ связи с другими признаками

**Что проверить:**
1. Распределение Embarked по Pclass
2. Распределение Embarked по Fare
3. Выживаемость по Embarked
4. Наиболее вероятное значение для пропущенных пассажиров

**Код:**
```python
# Анализ связи Embarked с Pclass
print("Распределение Embarked по Pclass:")
print(df_train.groupby('Pclass')['Embarked'].value_counts())

# Анализ связи с Fare
print("\nСредний Fare по Embarked:")
print(df_train.groupby('Embarked')['Fare'].mean())

# Найти пассажиров с пропущенным Embarked
missing_embarked = df_train[df_train['Embarked'].isna()]
print("\nПассажиры с пропущенным Embarked:")
print(missing_embarked[['Pclass', 'Fare', 'Sex', 'Title']])
```

#### Шаг 2: Заполнение Embarked

**Стратегия:**
- Если у пассажира с пропуском известны Pclass и Fare, найти наиболее вероятный Embarked для этой комбинации
- Если информации недостаточно, использовать моду (наиболее частое значение)

**Код:**
```python
# Найти моду Embarked
mode_embarked = df_train['Embarked'].mode()[0]
print(f"Мода Embarked: {mode_embarked}")

# Заполнить пропуски
df_train['Embarked'].fillna(mode_embarked, inplace=True)

# Или более умный подход - по Pclass
# Для 1-го класса чаще всего 'C' или 'S'
# Проверить конкретные случаи и заполнить вручную или по логике
```

#### Шаг 3: Проверка влияния

**Что проверить:**
- Распределение Embarked до и после
- Влияние на выживаемость
- Корректность заполнения

---

### 2.3 Fare (цена билета) - 1 пропуск в test.csv

#### Шаг 1: Анализ пропусков в test.csv

**Что сделать:**
1. Найти пассажира с пропущенным Fare
2. Проанализировать его характеристики (Pclass, Embarked, Title, etc.)
3. Определить наиболее подходящий способ заполнения

**Код:**
```python
# Найти пропуски Fare в test
missing_fare_test = df_test[df_test['Fare'].isna()]
print("Пассажиры с пропущенным Fare в test:")
print(missing_fare_test[['Pclass', 'Embarked', 'Sex', 'Title', 'SibSp', 'Parch']])

# Анализ среднего Fare по группам в train
print("\nСредний Fare по Pclass:")
print(df_train.groupby('Pclass')['Fare'].mean())
print("\nМедианный Fare по Pclass:")
print(df_train.groupby('Pclass')['Fare'].median())
```

#### Шаг 2: Заполнение Fare

**Стратегия:**
- Заполнить медианой Fare по Pclass (более устойчиво к выбросам)
- Или использовать медиану по Pclass + Embarked для большей точности

**Код:**
```python
# Заполнение медианой по Pclass
for pclass in df_test[df_test['Fare'].isna()]['Pclass'].unique():
    median_fare = df_train[df_train['Pclass'] == pclass]['Fare'].median()
    df_test.loc[(df_test['Fare'].isna()) & (df_test['Pclass'] == pclass), 'Fare'] = median_fare

# Или более точный подход - по Pclass + Embarked
def fill_fare(row):
    if pd.notna(row['Fare']):
        return row['Fare']
    
    group = df_train[(df_train['Pclass'] == row['Pclass']) & 
                      (df_train['Embarked'] == row['Embarked'])]
    
    if len(group) > 0:
        return group['Fare'].median()
    else:
        return df_train[df_train['Pclass'] == row['Pclass']]['Fare'].median()

df_test['Fare'] = df_test.apply(fill_fare, axis=1)
```

#### Шаг 3: Проверка выбросов

**Что проверить:**
- Распределение Fare после заполнения
- Наличие выбросов (особенно высоких значений)
- Возможно, применить логарифмирование для нормализации

---

### 2.4 Cabin (каюта) - 687 пропусков (77%)

#### Решение: использовать или удалить признак

**Вариант A: Использовать производные признаки (рекомендуется)**

**Уже созданы:**
- `is_Cabin` - есть/нет каюта (бинарный признак)
- `Id_cabin` - первая буква каюты (палуба)

**Дополнительно можно создать:**
- `Cabin_Count` - количество кают у пассажира (если несколько)
- `Deck` - палуба (извлечь из номера каюты)

**Преимущества:**
- Признак информативен (сильная связь с выживаемостью)
- Производные признаки не требуют заполнения пропусков
- Можно использовать в модели

**Код:**
```python
# Уже создано ранее:
# df_train['is_Cabin'] = df_train['Cabin'].apply(lambda x: 0 if pd.isna(x) else 1)
# df_train['Id_cabin'] = df_train['Cabin'].apply(lambda x: str(x)[0] if pd.notna(x) else 'Unknown')

# Дополнительно: количество кают
df_train['Cabin_Count'] = df_train['Cabin'].apply(
    lambda x: len(str(x).split()) if pd.notna(x) else 0
)

# Для test аналогично
df_test['is_Cabin'] = df_test['Cabin'].apply(lambda x: 0 if pd.isna(x) else 1)
df_test['Id_cabin'] = df_test['Cabin'].apply(lambda x: str(x)[0] if pd.notna(x) else 'Unknown')
df_test['Cabin_Count'] = df_test['Cabin'].apply(
    lambda x: len(str(x).split()) if pd.notna(x) else 0
)
```

**Вариант B: Удалить признак**

**Когда использовать:**
- Если производные признаки не улучшают модель
- Если слишком много пропусков и признак не информативен

**Код:**
```python
# Удалить исходный признак Cabin
df_train.drop('Cabin', axis=1, inplace=True)
df_test.drop('Cabin', axis=1, inplace=True)
```

---

### Чек-лист выполнения этапа 2

**Перед началом:**
- [ ] Сохранить копию исходных данных для сравнения
- [ ] Проверить количество пропусков в train и test

**Age:**
- [ ] Проанализировать зависимость Age от Pclass, Sex, Title
- [ ] Выбрать стратегию заполнения (медиана по группам или модель)
- [ ] Заполнить пропуски в train и test
- [ ] Проверить распределение до и после
- [ ] Убедиться, что статистики не сильно изменились

**Embarked:**
- [ ] Найти пассажиров с пропущенным Embarked
- [ ] Проанализировать их характеристики
- [ ] Заполнить пропуски (мода или по логике)
- [ ] Проверить корректность

**Fare:**
- [ ] Найти пассажиров с пропущенным Fare в test
- [ ] Заполнить медианой по Pclass (или более точным методом)
- [ ] Проверить на выбросы

**Cabin:**
- [ ] Решить: использовать производные признаки или удалить
- [ ] Создать is_Cabin, Id_cabin для train и test
- [ ] Проверить влияние на выживаемость

**Финальная проверка:**
- [ ] Убедиться, что в train нет пропусков (кроме Cabin, если удаляем)
- [ ] Убедиться, что в test нет пропусков
- [ ] Проверить, что все изменения применены одинаково к train и test
- [ ] Сохранить обработанные данные

---

### Важные замечания

1. **Всегда применяйте одинаковые преобразования к train и test!**
   - Если заполняете Age медианой по Pclass+Sex в train, делайте то же самое в test
   - Сохраняйте параметры заполнения (медианы, моды) для использования на test

2. **Не создавайте data leakage!**
   - Не используйте информацию из test для заполнения train
   - Не используйте Survived для заполнения других признаков

3. **Документируйте все решения:**
   - Записывайте, какой метод использовали
   - Сохраняйте параметры (медианы, моды)
   - Объясняйте логику выбора метода

4. **Проверяйте качество:**
   - Сравнивайте распределения до и после
   - Проверяйте влияние на корреляции
   - Убеждайтесь, что не создали артефакты

---

## Этап 3: Feature Engineering (создание новых признаков)

### 3.1 Извлечение информации из Name
- [x] Извлечение титула (Title) из имени
- [ ] Группировка редких титулов
- [ ] Создание признака Title_encoded
- [ ] Анализ влияния титула на выживаемость
- [ ] Возможные титулы: Mr, Mrs, Miss, Master, Dr, Rev, etc.

### 3.2 Семейные признаки
- [x] Family_Size = SibSp + Parch + 1
- [ ] Is_Alone (Family_Size == 1)
- [ ] Family_Category (маленькая/средняя/большая семья)
- [ ] Анализ оптимальных границ для категорий

### 3.3 Возрастные категории
- [ ] Age_Group (ребенок/взрослый/пожилой)
- [ ] Is_Child (Age < 18)
- [ ] Is_Elderly (Age > 60)
- [ ] Анализ оптимальных границ

### 3.4 Признаки из Ticket
- [ ] Анализ структуры номеров билетов
- [ ] Группировка по общим префиксам
- [ ] Ticket_Count (количество людей с одинаковым билетом)
- [ ] Возможное удаление, если не информативен

### 3.5 Признаки из Cabin
- [x] is_Cabin (наличие каюты)
- [x] Id_cabin (первая буква)
- [x] Deck (палуба) - если можно извлечь
- [x] Cabin_Count (количество кают у пассажира)

### 3.6 Взаимодействия признаков
- [x] Sex_Pclass (комбинация пола и класса)
- [x] Age_Pclass (возраст и класс)
- [x] Fare_per_Person (Fare / Family_Size)
- [x] Title_Age (титул и возраст)



---

## Этап 4: Подготовка данных для моделирования

### 4.1 Кодирование категориальных признаков
- [x] One-Hot Encoding для номинальных признаков (Embarked, Id_cabin)
- [x] Label Encoding для порядковых признаков (Sex, Title)
- [x] Проверка корректности кодирования

### 4.2 Разделение данных
- [x] Разделение train на train/validation (80/20 или 70/30)
- [x] Использование StratifiedSplit для сохранения баланса классов


---

## Этап 5: Выбор и обучение моделей

### 5.1 Базовые модели (baseline)
- [x] Логистическая регрессия
- [x] K-Nearest Neighbors (KNN)
- [x] Наивный Байес
### 5.2 Деревья решений и ансамбли
- [x] Decision Tree
- [x] Random Forest
- [x] Gradient Boosting (XGBoost, LightGBM, CatBoost)
- [x] Extra Trees

### 5.3 Другие алгоритмы
- [x] Support Vector Machine (SVM)

### 5.4 Гиперпараметры
- [x] Grid Search или Random Search

### 5.5 Оценка моделей
- [ ] Accuracy на validation set
- [ ] Confusion Matrix
- [ ] Precision, Recall, F1-score
- [ ] ROC-AUC curve
- [ ] Feature Importance для интерпретации

---

## Этап 6: Ансамблирование и оптимизация

### 6.1 Создание ансамбля
- [x] Voting Classifier (hard/soft voting)




---

## Этап 7: Предсказания и submission

### 7.1 Финальные предсказания
- [x] Обучение финальной модели на всем train.csv
- [x] Предсказания для test.csv
- [x] Проверка формата предсказаний (0 или 1)

### 7.2 Подготовка submission файла
- [x] Создание DataFrame с PassengerId и Survived
- [x] Проверка количества строк (418 + заголовок)
- [x] Проверка отсутствия NaN значений
- [x] Сохранение в CSV формат

### 7.3 Валидация submission
- [x] Проверка формата файла
- [x] Проверка диапазона значений (0 или 1)
- [x] Проверка количества записей

---



